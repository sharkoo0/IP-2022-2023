### Указател към константа
Нещата, които разглеждахме предния път бяха за **неконстантни** указатели, сочещи към **неконстантни** стойности.
```
int x = 5;
int *px = &x;
```

Какво обаче се случва ако имаме const int x?
```
const int x = 5;
int *px = &x;
```

Горният фрагмент код няма да се компилира - не можем да зададем указател без const към стойност const. 

#### Указател към константа
Указател към константа е **неконстантен** указател, който сочи към постоянна стойност. 
**Синтаксис**
```
const <type> *<name> = &<value>;
value - е константа или променлива, която не може да променя стойността си чрез указателя.
```
Пример:
```
const int value = 5;
const int *p = &value;
*p = 6; // Не е позволено
```

```
int value = 5;
const int *p = &value;
*p = 6; // Не е позволено
value = 6; // Позволено е
```

**Указател към константа може да сочи към неконстантна стойност.** Помислете го от тази страна: Указателят към константа се отнася към стойността като константа, независимо от нейното деклариране.
Тъй като указателят към константа не е константен, той може да бъде пренасочен към друга стойност:
```
int value1 = 5;
const int *p = &value1;

int value2 = 6;
p = &value2;
```

**Обощение: При указател към константа, стойността, към която той сочи, не може да бъде променяна чрез него.**

#### Константен указател
Казахме, че указателят е тип променлива. Както имаме константи, така имаме и константни указатели. **Константният указател е указател, чиято стойност не може да се променя след инициализация.**
**Синтаксис:**
```
<type> *const <name> = &<value>;
value - е променлива
```
Пример:
```
int value = 5;
int *const p = &value;
```

Както константите, константният указател **трябва да се инициализира със стойност при декларацията си.** Това означава, че константният указател **ВИНАГИ** ще сочи към един и същ адрес в паметта.
```
int x1 = 5;
int x2 = 6;

int *const p = &x1;
p = &x2; // Невалидно
```

Тъй като стойността, към която сочи, е възможно тази стойност да бъде променена чрез указателя.
```
int x = 5;
int *const p = &x;
*p = 6;
```

**Обобщение: Стойността на константния указател (адреса, към който сочи) не може да бъде променяна, но стойността, която се намира на този адрес може.**

#### Константен указател към константа
Възможно е да се дефинира константен указател към константа. 
```
const <type> *const <name> = &<value>;
```

Пример:
```
int value = 5;
const int *const p = &value;
```

Константният указател към константа **НЕ МОЖЕ** да бъде пренасочен към друга стойност, **нито може да променя стойността на адреса**, към който той сочи.

***Трябва да запомните 4 правила при работа с указатели:***
- Неконстантен указател може да бъде пренасочван към други адреса
- Константен указател сочи към един и същ адрес и този адрес не може да бъде променян
- На указател към неконстантна стойност може да се променя стойността, която той сочи. Те не могат да сочат към константи.
- Указател към константа се отнася към стойността като константа (дори да не е) и по този начин не може да променя стойността на адреса, към който сочи.

### Референции (References) или псевдоними
#### Декларация на референция
Референцията се декларира като се постави '&' между типа на референцията и името на променливата:
```
int a = 5;
int &ref = a;
```

Тук '&' не означава **"адресът на"**, а означава **"псевдонимът на"**. Псевдонимите действат идентично на стойностите, към които се отнасят. Тоест каквото направим с псевдонима, то се отразява на самата променлива.
Пример:
```
#include <iostream>

int main()
{
    int value = 3; // Нормално цяло число
    int &ref = value; // Псевдоним на променливата value
 
    value = 5; // value вече е 5
    ref = 13; // value вече е 13
 
    ++value;
    std::cout << value << std::endl;
    ++ref;
    std::cout << value << std::endl;
 
    return 0;
}
``` 

Компилаторът се отнася към value и ref като към синоними. Освен това, когато приложим "address-of" оператора към ref, получаваме адреса на value:
```
#include <iostream>

int main()
{
    int value = 3; // Нормално цяло число
    int &ref = value; // Псевдоним на променливата value
 
    std::cout << &value << std::endl;
    std::cout << &ref << std::endl;

    return 0;
}
```

***Няколко неща, на които трябва да обърнем внимание:***
- Референциите трябва да бъдат инициализирани при създаването си!
- Неконстантни референции могат да бъдат инициализирани **САМО** с неконстантни променливи(стойности)!
- Веднъж инициализирана референцията **НЕ МОЖЕ** да бъде псевдоним на друга променлива, а просто взима стойността й!
- За разлика от указателите, които могат да имат нулева стойност, **няма такова нещо** при псевдонимите.

#### Константни референции
**Референцията към константа (или константен псевдоним) е различно от указател!!!**

Както имаме възможност да декларираме указатели към константа, така можем и да декларираме референция към константа.
```
const int value = 5;
const int &ref = value;
```

Подобно на указател към константа, **референцията към константа може да реферира към неконстантна стойност**. При достъп чрез референцията стойността се счита за константа.
```
int value1 = 5;
const int &ref1 = value1;

const int value2 = 6;
const int &ref2 = value2;
```

**Обобщение: При референция към константа, стойността(константа или не), достъпвана чрез псевдонима, не може да бъде променяна. Може да се променя самата променлива.**

### Функции (advanced)
#### Параметри vs. аргументи
**Параметър** на функция (наричан още **формален параметър**) е променлива, използвана при декларация/дефиниция на функцията.
```
void foo(int x); // декларация (прототип на функцията) - х е параметър

void foo(int x) { // дефиниция - х е параметър

}
```

**Аргумент** (наричан още **действителен параметър**) е стойността, която се подава на функцията при нейното извикване.
```
foo(6); // 6 е аргумент предаден на параметъра х
```

Когато някъде се извика функцията foo() се с аргумента 6, параметърът х на foo се създава и инициализира със стойността на аргумента(т.е. със 6). Параметрите имат локална видимост и затова, когато функцията завърши изпълнението си те се разрушават.

```
void foo(int x) { // х се създава

} //х се унищожава
```

#### Подаване на аргументи към функции по стойност, адрес и референция
Когато използваме функции(както го правим до сега) и подаваме даден аргумент (подаване по стойност), ние дефакто създаваме нова променлива някъде в паметта и всички промени, които осъществим се правят над новата променлива, но не и над променливата, която сме подали.
За да правим промени над оригиналните променливи, които сме подали, се използват указателите и псевдонимите.

Казано разговорно какво представляват: - Псевдонимът казва, когато подадеш дадена променлива, на тази която се присвоява, направо я взима по референция, т.е направо я вземи където се намира по адреса, който е и оперира в оригиналната памет. - Указател - подаваме адреса на променливата и оперираме над него

Пример: Искаме да намерим сумата на две числа, като използваме трета променлива в която да се пази резултата. (т.е за учебна цел няма да връщам сумата като резултат, а ще пазя резултата в предварително създадена променлива)
```
#include <iostream>

// without reference or pointer => will lose value of sum
void sumWithoutRefOrPointer(int numL, int numR, int sum)
{
    sum = numL + numR;
}

// with reference
void sumIt(int numL, int numR, int &sum)
{
    sum = numL + numR;
}

// with pointer
void sumIt(int numL, int numR, int *sum)
{
    *sum = numL + numR;
}

int main()
{
  int numL = 4, numR = 6, sum = 0;
  
  sumWithoutRefOrPointer(numL, numR, sum);
  std::cout << "1) " << sum << std::endl; // 0
  
  sumIt(numL, numR, sum);
  std::cout << "2) " << sum << std::endl; // 10
  
  sumIt(numL + 1, numR, &sum);
  std::cout << "3) " << sum << std::endl; // 11

  return 0;
}
```

Виждаме това което коментираме до сега. Там къде сме подали по стойност (т.е. първата функция), правим копие и след края на изпълнение се трие това копие, като стойността на sum (това е main) не е променена. Когато подаваме по референция ние работим директно в паметта и от там идва и промяната на стойността на променливата sum. При използването на указател наблюдаваме същото, вземи адреса на променливата и след това с '*' казваме влез вътре и промени стойността.