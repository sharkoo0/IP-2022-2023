### I. Преобразувания (cast)
Преобразуванията служат за смяна на типа на стойността на дадена променлива. Например, ако имаме символът '1', можем да го преобразуваме до числото 1.
Видове преобразувания:
1. **Явно (_implicit_)** - Можем явно да преобразуваме стойности на променливи. Например: Нека имаме променливата от целочислен тип int a = 5;. Нека създадем променливата от числов тип с плаваща запетая double b = (int)a. По този начин променливата b има стойност 5.0.  
2. **Неявно (_explicit_)** - Има случаи, в които не виждаме преобразуването на стойностите. Например: Нека имаме променливата char a = 'A'. Създаваме променливата int b = a;. В този случай променливата b има стойност 65. (ASCII table - след малко)

### II. Булеви преобразувания към целочислен тип и обратно
1. bool -> int
```
    bool a = true;
    int b = a;
    cout << b << endl; //Изход: 1
```
Всяка булева променлива може да се представи като променлива от целочислен тип. В този слувай целочислената променлива ще има стойност 1. В случаите, когато булевата променлива има стойност false, целочислената променлива ще има стойност 0.

2. int -> bool
```
    int a = 0;
    bool b = a;
    cout << b << endl; //Изход: 0 (false)
```
За да видим думата false в конзолата, трябва да използваме вградената команда boolalpha.
```
    cout << boolalpha << b << endl; //Изход: false
```

### III. Преобразуване на символ към целочислен тип и обратно
1. ASCII table - American Standard Code for Information Interchange https://www.asciitable.com/
2. char -> int
```
    char a = 'A';
    int b = a;
    cout << b << endl; //Изход: 65 Символът 'А' е номер 65 в ASCII таблицата. Поради тази причина стойността на b е 65.
```
3. int -> char
```
    int a = 97;
    char b = a;
    cout << b << endl; //Изход: a Символът на 97 позиция е 'а', затова стойността на b е 'а'.
```

#### Какъв ще е резултатът от следния код:
```
    char c = 'F';
    int result = c - 5;
    cout << result << endl;
    char newChar = result;
    cout << newChar << endl;
```

### IV. Булеви изрази (Boolean expressions)
1. Едно условие

Както видяхме в предното упражнение, когато искаме да проверим дали дадено нещо е истина или не, използваме типа bool в различни булеви изрази. Видяхме също, че операторите за сравнение връщат булева (логическа) стойност, но с тях може да се сравнява само едно условие. Например, ако искаме да проверим дали две числа са равни, можем директно да изведем резултата от сравнението.
```
    int x = 5;
    int y = 3;
    cout << x == y; // 0
    cout << x >= y; // 1
    cout << x != y; // 1
```
2. Няколко условия

А какво се случва, когато искаме да са изпълнени няколко условия наведнъж? Например, ако искаме да проверим дали две неща съвпадат, то трябва да сравним възможно най-много техни характеристики. Например, ако искаме да проверим дали печелим от лотарията, то трябва да проверим дали всички 6 числа от тегленето съвпадат с числата от нашия лотариен билет. Освен това, може да ни се наложи поне едно условие от няколко възможни е изпълнено. Например, ако закъсняваме за УП, то или сме изпуснали автобуса, или се мотаем пред ФМИ, или си пускаме билета за 6/49. В тези случаи, комбиниранраме различни булеви изрази в по-голям израз, като се интересуваме от неговия резултат. За да комбинираме използваме конюнкция(логическо-И) и дизюнкция(логическо-ИЛИ).

#### Какво ще изведе следния код:
```
    int x = 5;
    int y = 7;
    int z = y - x;

    cout << (x == y) && (z == (y - x)) << endl;
    cout << (!x == y) << endl;
```

Но смесването им, не е произволно. Тези оператори имат приоритет, както събирането и умножението в математиката. Логическото-И има по-висок приоритет от логическото-ИЛИ, така че логическите-И оператори ще бъдат оценявани преди логическите-ИЛИ оператори. Например изрази като value1 || value2 && value3 се оценява като value1 || (value2 && value3), a не като (value1 || value2) && value3.

### NB!
При смесване на логически-И и логически-ИЛИ оператори в един и същ израз е добра практика изрично да се посочат операндите на всеки оператор. Това помага да се предотвратят грешките с приотитета, прави кода ви по-лесен за четене и ясно дефинира как сте възнамерявали да оценявате израза. Например, вместо да напишете value1 && value2 || value3 && value4, по-добре напишете (value1 && value2) || (value3 && value4).

#### Закони на Де Морган - за логическото отрицание
Законите на Де Морган ни казват как трябва да се преобразуват логическите изрази в тези случаи:
```
    !(X && Y) е еквивалентно на !X || !Y
    !(X || Y) е еквивалентно на !X && !Y
```
С други думи, когато използвате логическo-НЕ, трябва да обърнете логическoто-И към логическо-ИЛИ, и обратно!

### V. Блок {} (Block), обхват или видимост (Scope)
**Блок** в програмата ще наричаме парче код, заградено в къдрави скоби {}. Конвенцията за писане на код изисква първият ред код да започва на реда, след отварящата къдрава скоба, всеки ред в блока да е с подходяща идентация (т.е. да е по-навътре от отварящата скоба - най-често се използва табулация) и затварящата скоба на блока да е на нов ред. Това не е задължително за коментари в кода.
*Този вариант отговаря на конвенцията.*
```
if (true) { // ще разгледаме този оператор след малко
    int a = 5;
    cout << a << endl;
}
```
*Този вариант също отговаря на конвенцията.*
```
if (true)
{
    int a = 5;
    cout << a << endl;
}
```
*Този, обаче, **не** отговаря на конвенцията.*
```
if (true) {int a = 5; cout << a << endl;}
```
Можем да имаме вмъкнати блокове (подблокове) в други блокове. В такъв случай идентацията на вмъкнатия блок започва още по-навътре.
```
if (true) {
    if (true) {
        if (true) {
            int a = 5;
            cout << a << endl; 
        }
    }
}
```
**Scope (обхват/видимост)** на променливи наричаме частта на програмата, където можем да достъпим променливата и нейната стойност. Видимостта можем да я категорицираме на 3 категории:
1. Вътрешна или локална променлива - Намира се вътре в дадена функция или блок.
2. *Формален параметър (в декларация/дефиниция на функция) - След няколко седмици ще разгледаме тази категория.*
3. Глобална променлива - Намира извън всякакви функции и блокове.

Локалните променливи са видими в блока, в който са декларирани, и във всеки негов подблок. Глобалните променливи са декларирани извън всички блокове, най-често най-отгоре, и са видими във всички блокове и могат да се достъпят от всякъде в програмата.

***Извод:*** Избягвайте използването на глобални променливи, ако е възможно! Ако ги използвате, бъдете разумни и предпазливи.
Нека видим един пример за видимостта на променливите:
```
#include <iostream>
using namespace std; //за този ред след малко

int globalVariable = 5;

int main() {
    int localMainVariable = 6;

    if (true) {
        int localIfvariable = 7;

        if (true) {
            int localVariable = 8;
            //Тук всички променливи са видими
            cout << localVariable << endl;
            cout << localIfvariable << endl;
            cout << localMainVariable << endl;
            cout << globalVariable << endl;
        }

        //Тук една от променливите не е видима. Можете ли да познаете коя?
        cout << localVariable << endl;
        cout << localIfvariable << endl;
        cout << localMainVariable << endl;
        cout << globalVariable << endl;
    }

    //Тук две от променливите не са видими. Кои са те?
    cout << localVariable << endl;
    cout << localIfvariable << endl;
    cout << localMainVariable << endl;
    cout << globalVariable << endl;

    if (true) {
        //Кои променливи са видими тук, ако има такива?
    }

    return 0;
}
```

### VI. Условни оператори (if statement, switch, Ternary operator)
### 1. if statement
Контролирането потока на програмата, взимането на решение кога дадени фрагменти да се изпълнят и кога не, е важно умение за всеки програмист. За това умение се използват различни инструменти. Един такъв инструмент е условният оператор, той проверява дали дадено условие е изпълнено и спрямо този резултат изпълнява зададено следствие от програмистта. Условният оператор има две основни конструкции (форми): кратка и пълна.

#### Кратка форма
**Синтаксис:**
```
    if (<условие>) {
        <блок от операции, които ще бъдат изпълнени>
    }
```
**Семантика:**
Проверява се резултатът от <условие>, ако върнатата стойност е true тогава се изпълнява блокът от операции, ако върнатият резултат е false блокът се пропуска, т.е. няма да се изпълни нищо.
**Пример:**
```
#include <iostream>
using namespace std; //за този ред след малко

int main()
{
	const int ALLOW_AGE = 18;
	int age = 16;
	
	if (age < ALLOW_AGE) 
		cout << "Drink denied" << endl;

	return 0;
}
```
#### Пълна форма
**Синтаксис:**
```
if (<условие>) {
    <блок от операции, които ще бъдат изпълнени, ако <условие> бъде оценено до true>
} else {
    <блок от операции, които ще бъдат изпълнени, ако <условие> бъде оценено до false>
}
```
**Семантика:**
Проверява се резултатът от <булев_израз>, ако върнатата стойност е true тогава се изпълнява първият блок от операции, ако върнатият резултат е false - вторият блок.
**Пример:**
```
#include<iostream>
using namespace std; //за този ред след малко

int main()
{
	const int ALLOW_AGE = 18;
	int age = 16;
	
	if (age < ALLOW_AGE)
	{ 
		cout << "Drink denied" << endl;
	}	
	else
	{
		cout << "Drink permitted" << endl;
	} 

	return 0;
}
```

### Вложени условни оператори (nested if)
**Пример:**
```
#include<iostream>
using namespace std; //за този ред след малко

int main()
{
	int number = 15;
	
	if (number % 3 == 0)
	{
		if (!(number % 5))
			cout << "Divided by 3 and 5" << endl;
		else
			cout << "Divided by 3 but not by 5" << endl;
	}
	
	return 0;
}
```

### Форма if-else-if
**Синтаксис и семантика:**
```
if ( <условие> ) 
{
	// ...
  	// Ако <булев_израз> е оценен с true, ще се изпълни този блок с операции
  	// ...
}
else if ( <друго–условие> ) 
{
  	// ...
  	// Ако <друг_булев_израз> е оценен с true И <булев_израз> е оценен с false, 
  	// тогава ще се изпълни този блок с операции
  	// ...
}
else // тази клауза не е задължителна
{
  	// ...
  	// ще се изпълни този блок, ако <булев_израз> И <друг_булев_израз> са оценени с false
  	// ...
}
```
**Пример:**
```
#include<iostream>
using namespace std; //за този ред след малко

int main()
{
	int a = 19;
	if (a % 2 == 0)
	{
	    cout << "divided by 2" << endl;
	}
	else if (a % 3 == 0)
	{
		cout << "divided by 3" << endl;
	}
	else
	{
	    cout << "Not divided by 2 and 3" << endl;
	}

	return 0;
}
```

### 2. Конструкция ?: (Ternary operator)
?: е форма която наподобява конструкцията if - else. Формално ще наричаме оператора ?: тернарен оператор (тернарен, тъй като приема 3 аргумента).
**Синтаксис:**
```
<условие> ? <действие–при–истина> : <действие–при–лъжа>;
```
**Семантика:**
Първо изчислява **<условие>**. Ако **<условие>** е изчислено до true, се изпълнява **<действие–при–истина>**. В противен случай се изпълнява **<действие–при–лъжа>**.

**Пример:**
```
#include<iostream>
using namespace std; //за този ред след малко

int main()
{
	const int ALLOW_AGE = 18;
	int age = 19;

	cout << (age < ALLOW_AGE ? "Drink denied" : "Drink permitted") << endl;
	
	return 0; 
}
```
Кога е удобно да се използва този оператор?

### 3. switch statement
Операторът switch позволява проверката на дадена променлива за равенство измежду списък от стойностти. Всяка стойност за проверка се нарича случай (case).
**Синтаксис:**
```
switch (<израз|стойност>) {
    case <първа–стойност–за–проверка>: {
        <операции–за–изпълнение>
        break; //break не е задължителен
    }
    case <втора–стойност–за–проверка>: {
        <операции–за–изпълнение>
        break; //break не е задължителен
    }
    case <трета–стойност–за–проверка>: {
        <операции–за–изпълнение>
        break; //break не е задължителен
    }
    default: {
        <операции–за–изпълнение>
        break; //break не е задължителен. Тук дори е излишен
    }
}
```
**Семантика:**
Подаваме стойност на switch, след което последователно се проверяват всички case-ове, които сме описали. Ако някой от случаите се оцени до true, то изпълняваме операциите в съответния блок. Когато стигнем до break;, излизаме от switch оператора и продължаваме изпълнението на програмата. Ако никой от описаните случаи не е равен на <стойност>, то тогава влизаме в default блока (ако има такъв). Ако няма default блок, продължаваме с изпълнението на програма. Ако нямаме break;, то е възможно да влезем в повече от един блок за изпълнение на операции. **Кога е възможно това?**
**Пример:**
```
#include <iostream>
using namespace std; //за този ред след малко

int main() {
    int number = 7;
    switch (number) {
        case 1: {
            cout << "January" << endl;
            break;
        }
        case 2: {
            cout << "February" << endl;
            break;
        }
        case 3: {
            cout << "March" << endl;
            break;
        }
        ...
        default: {
            cout << "Not valid month!" << endl;
        }
    }
}
```
**Как би изглеждал горния код, ако сме решили да го напишем с if statement? Помислете коя форма на if бихме използвали, ако има break и ако няма. Помислете също за формата на if, ако имаме default и ако нямаме.**

**Допълнителни ограничения за switch**
1. Може да имате **неограничен брой случаи (case)**, като трябва за всеки един да дадете стойност, по която да се проверява.
2. Стойносттите, по които проверяваме, трябва да бъдат от **същия тип** както подадената за проверка.
3. При откриване на съвпадение се изпълняват подадените операции до срещане на **оператор break**, т.е ако сме влезли във втория case и **няма break** в него, ще се изпълнят всички оператори в останалите case-ове до достигане на оператор break или до края на блока на switch statement-a.
4. При стигане до break, изпълнението на оператора switch се прекратява и продължава изпълнението на програмата след него.
5. default е опционален, т.е не е от задължителния синтаксис на оператора switch. Той се използва когато никой от изброените условия не се е изпълнило и искаме да отбележим това.

**Кога е удобен за използване операторът switch?**

### VII. Namespace std
C++ изисква всички идентификатори (имена на променливи и/или функции) да не са двусмислени. Ако два идентификатора са въведени в една и съща програма по начин, който компилаторът не може да ги разграничи, съставителят или линкерът ще доведе до грешка. Тази грешка обикновено се нарича "конфликт с именуването". Тъй като програмите се увеличават и използват повече идентификатори, шансовете за конфликт между имената се увеличават значително.

Когато C ++ бил първоначално проектиран, всички идентификатори в стандартната библиотека C++ (като cin и cout) били на разположение за директно използване. Това обаче означава, че всеки идентификатор в стандартната библиотека може потенциално да е в конфликт с името, което сте избрали за вашите собствени идентификатори. Така че, разработчиците C++ преместили цялата функционалност на стандартната библиотека в специална област, наречена пространство с имена или namespace.

Подобно на град, който гарантира, че всички пътища в града имат уникални имена, пространството с имена гарантира, че идентификаторите в пространството на имената са уникални. Това предотвратява конфликтите на идентификаторите в пространство от имена с други идентификатори.

#### using namespace std;

Оказва се, че името на оператора за изход std::cout, което използваме в повечето си примери, не е наистина "std::cout". Това всъщност е просто "cout", а "std" е името на пространството с имена, в което името живее. Цялата функционалност в стандартната библиотека C++ се дефинира в пространство с имена std (кратко за standard). По този начин не е нужно да се притесняваме за функционалността на стандартната библиотека, която има конфликт на именуване с нашите собствени идентификатори.

За да избегнем постоянното пояснение към компилатора, използваме ключовия ред using namespace std; веднага след добавянето на необходимите ни библиотеки.




