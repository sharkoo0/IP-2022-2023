### Цикли (loops)
Какво правим ако искаме да сметнем *5!*? Може би нещо такова:
Пример 1:
```
#include <iostream>
using namespace std;

int main() {

    cout << 1 * 2 * 3 * 4 * 5 << endl;

    return 0;
}
```
Добре, това парче код работи в този случай. А какво правим, ако искаме да изведем стойностите на *3!*, *4!*, *5!*, *6!*, *7!*, *8!*, *9!* и *10!*? Може би нещо такова: 
Пример 2:
```
#include <iostream>
using namespace std;

int main() {

    cout << 1 * 2 * 3 << endl;
    cout << 1 * 2 * 3 * 4 << endl;
    cout << 1 * 2 * 3 * 4 * 5 << endl;
    cout << 1 * 2 * 3 * 4 * 5 * 6 << endl;
    cout << 1 * 2 * 3 * 4 * 5 * 6 * 7 << endl;
    cout << 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 << endl;
    cout << 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 << endl;
    cout << 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 << endl;

    return 0;
}
```
Отново работи! А какво правим, ако искаме всички стойности до *100!*? По горния начин ще стане, но ще отнеме вечност. Тъпо и неефктивно решение, НО работи. 
Какво, обаче, забелязваме в горните примери. Повтаряме една и също операция определен брой пъти, докато не се наруши някакво условие (*в 'Пример 2' условието е числото, на което смятаме факториел, да не е по-голямо от 10*). Следователно можем да забележим, че съществува повторение или цикличност на тази операция.
#### Основни части на цикъла:
**1 - инициализация (initialization)** - Задаваме начална стойност на променливата, която участва в цикъла.
**2 - тяло на цикъла (body)** - Това е блок, който съдържа операторите, които искаме да се повтарят многократно.
**3 - актуализация (update)** - Обновяват се стойностите на някой от променливите преди всяка следваща стъпка (*без първата*).
**4 - условие за край на цикъла (condition)** - Служи за прекратяване на повторенията.

#### Цикли с предусловие
### **for loop** 

**Синтаксис:**
```
for (<инициализация>; <условие>; <актуализация>) {
    <тяло>
}
```
**Семантика:**
Изпълнението започва с **инициализирането** на стойностите, след което се проверява **условието**. Ако резултатът е ***true***, то изпълняваме операциите в тялото на цикъла. Ако е ***false***, продължаваме изпълнението на програмата след цикъла. След като сме изпълнили тялото се **актуализират** променливите. След което отново се проверява условието. Ако резултатът е ***true***, то изпълняваме операциите в тялото на цикъла. Ако е ***false***, продължаваме изпълнението на програмата след цикъла и т.н. докато условието не върна ***false***.

Пример: Отпечатваме всички цифри в нарастващ ред
```
#include <iostream>
using namespace std;

int main() {

    for (int number = 0; number < 10; number++) {
        cout << number << " ";
    }

    return 0;
}
```

### **while loop**

**Синтаксис:**
```
while (<условие>) {
    <тяло>
}
```
**Семантика:**
Семантика: Проверява се резултатът от **условието**, ако върнатата стойност е ***true*** тогава се изпълнява **тялото**, ако върнатият резултат е ***false*** - се прекратява изпълнението на while оператора и продължава изпълнението на кода след него. ***Някъде в тялото на цикъла трябва да има актуализация, в противен случай ще стигнем до безкраен цикъл.***

Пример: Отпечатваме всички цифри в нарастващ ред
```
#include <iostream>
using namespace std;

int main() {
    int number = 0;
    while (number < 10) {
        cout << number << " ";
        number++; // === ++number === number = number + 1
    }

    return 0;
}
```
#### NB! 
Възможно е нито веднъж да не влезем в тялото на циклите с предусловие.


#### Цикли със следусловие
За разлика от циклите с предусловие при този вид цикли ***задължително*** тялото на цикъла се изпълнява **поне вендъж**. Сега ще разберем защо.

### **do-while loop**
**Синтаксис:**
```
do {
    <тяло>
} while (<условие>);
```
### !!! Обърнете внимание, че след 'while (<условие>)' има ; !!!

**Семантика:**
Първо се изпълнява **тялото** на цикъла, след което се проверява **условието**. Ако резултатът е ***true***, то изпълняваме отново тялото. В противен случай прекратяваме изпълнението и продължаваме с изпълнението програмата след цикъла. Тук забелязваме, че отново нямаме **актуализиране** на стойностите. ***Някъде в тялото на цикъла трябва да има актуализация, в противен случай ще стигнем до безкраен цикъл.***

Пример: Отпечатваме всички цифри в нарастващ ред
```
#include <iostream>
using namespace std;

int main() {
    int number = 0;
    do {
        cout << number << " ";
        ++number;
    } while (number < 10);

    return 0;
}
```

### NB!
При while и do-while циклите инициализацията се извършва извън конструкцията на цикъла. Във всяка една от разгледаните конструкции може да се пропусне всяка от 4-те части, но в резултат може да получим неработеща програма. **Внимавайте!** Проверявайте дали имате случай, при които ще се прекрати изпълнението на цикъла, в противен случай ще получите безкраен цикъл.

Ето пример за безкраен цикъл:
```
#include <iostream>
using namespace std;

int main() {
    for (int number = 0; number < 10; --number) {
        cout << number << " ";
    }

    reutrn 0;
}
```

### Оператор break
Нека имаме редица от числа със случайна подредба (например 13, 54, 2, 6, 98, 7, 5). Искаме да намерим числото 98. 

Започваме последователно да сравняваме числата от редицата с нашето число 98. Виждаме, че 98 е в средата на редицата. Супер, we found it! Трябва ли да продължаваме да сравняваме и другите числа? - НЕ! Тогава как да прекратим търсенето? Тук на помощ идва операторът break. Той казва на цикъла, в който се намира, да приключи изпълнението си.

Пример:
```
#include <iostream>
using namespace std;

int main() {
    int tempNumber;
    int sizeOfSequence;

    cin >> sizeOfSequence;

    for (int i = 0; i < sizeOfSequence; ++i) {
        cin >> tempNumber;
        if (tempNumber == 98) {
            cout << "Good job! You found the number." << endl;
            break;
        }
    }

    return 0;
}
```

### Помощни флагове (flag)
Друг начин да прекратим търсенето е чрез помощни флагове. Това са булеви променливи, които маркират промяна, ако е изпълнено дадено условие. Флаговете не е задължително да са булеви променливи, но най-често се използва bool.
Пример: (Ще използваме горния пример)
```
#include <iostream>
using namespace std;

int main() {
    int tempNumber;
    int sizeOfSequence;
    bool flag = false; //Сваляме флага

    cin >> sizeOfSequence;

    for (int i = 0; i < sizeOfSequence && !flag; ++i) {
        cin >> tempNumber;
        if (tempNumber == 98) {
            cout << "Good job! You found the number." << endl;
            flag = true; //Вдигаме флага
        }
    }

    if (flag) { // Може да се напише и flag == true, което е абсолютно същото
        cout << "Sorry! The number was not found." << endl;
    }

    return 0;
}
```

### Оператор continue
Видяхме, че чрез операторът break, можем удобно и лесно да прекратим цялостното изпълнение на цикъла. Операторът continue, от друга страна, предоставя удобна и лесна възможност да прекратим изпълнението на текущата итерация на цикъла, т.е. прескача частта от тялото на цикъла, която се намира след continue. 

Пример: (В редица от 10 случайни числа искаме да преброим САМО числата, кратни на 3)
```
#include <iostream>
using namespace std;

int main() {
    int tempNumber;
    int counter = 0;

    for (int i = 0; i < 10; ++i) {
        cin >> tempNumber;
        if (tempNumber % 3 == false) { //Може и да се запише само !(tempNumber % 3)
            continue;
        }
        ++counter;
    }

    cout << "The numbers divisible by 3 are " << counter << endl;

    return 0;
}
```

### Вложени цикли (nested loops)
Когато в тялото на един цикъл, имаме друг цикъл, тогава казваме, че имаме вложени цикли (nested loops). Можем да влагаме колкото искаме цикли като може те да са с различна конструкция. Тези цикли се използват най-често, когато работим с таблици (матрици).

Пример: (Отпечатваме числата от 1 до 9 в решетка)
```
#include <iostream>
using namespace std;

int main () {
    int k = 1;
    
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            cout << k << " ";
            ++k;
        }
        cout << endl;
    }

    return 0;
}
```