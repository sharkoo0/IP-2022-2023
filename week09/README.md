## Указатели и рефенции (pointers and references)

### Какво са указателите и за какво ни трябват?
В началото, когато учихме какво са променливите, казахме, че променливата е има (идентификатор) за клетка от паметта, която съдържа стойност. 
Например:
```
int x;
```
Когато изпълняваме операция, CPU отделя част от RAM паметта с размер 4 байта. За примера, нека кажем, че променливата x се намира на адрес 140 в паметта. Когато програма види нашата променлива в израз, тя знае, че трябва да отиде на адрес 140 и да вземе стойността на x.

#### За любознателните:
Всички компютри имат памет, известна също като RAM (random access memory). Например, компютърът ви може да има 16, 32, 64 и повече мегабайта RAM(днес вече говорим за гигабайти). RAM паметта съхранява програмите, които компютърът ви изпълнява заедно с данните, които те използват(променливи и структури от данни). Паметта може да се представи просто като масив от байтове. В този масив всяка клетка на паметта има свой собствен адрес - адресът на първия байт е 0, последван от 1, 2, 3 и т.н. Адресите на паметта действат точно като индексите на нормален масив. Компютърът има достъп до всеки адрес в паметта по всяко време (оттук и името "памет с произволен достъп"). Тя също така, може да групира байтове заедно, за да формира по-големи променливи, масиви или структури. Например, променлива с плаваща запетая консумира в паметта 4 съседни байта.

### Address-of operator (&)
Address-of (&) операторът ни позволява да видим **кой адрес в паметта е присвоен на променливата**. 
Пример:
```
#include <iostream>

int main() {
    int x = 5;
    std::cout << x << std::endl; // Извежда стойността на x
    std::cout << &x << std::endl; // Извежда адреса в паметта на x

    return 0;
}
```
Изход:
```
5
0x7822221582fc
```

### Value-of operator (*)
Value-of (*) операторът ни позволява да получим **стойността, съхранявана на определен адрес в паметта**.
```
#include <iostream>

int main() {
    int x = 5;
    int* p = &x;
    std::cout << x << std::endl; // Извежда стойността на x
    std::cout << &x << std::endl; // Извежда адреса в паметта на x
    std::cout << *p << std::endl; // Извежда стойността, съхранявана в клетката с адреса на x

    return 0;
}
```
Изход:
```
5
0x7822221582fc
5
```

### Указатели (pointers)
Указателят е **променлива** (NB! има тип), която съхранява **адрес в паметта като стойност**. Размерът на един указател е 4B. Както променлива от тип int съхранява цели числа, така и указателят съхранява адрес от вида 0x7822221582fc (16-тична бройна система).

#### Декларация на указател
Указателите се декларират като обикновени променливи, с изключение на това, че се поставя **'*' между типа и името на указателя**. Типът на указателя казва, че сочи към клетка, в която се съхранява стойността на променлива от същия тип. 
```
int* iPtr; // Указател от тип int
double* dPtr // Указател от тип double

//Може да се запише още и така:
int *iPtr2;
int * iPtr3; // Избягвайте този запис

int *iPtr4, *iPtr5;
```

При деклариране на няколко указателя, към всеки указател трябва да има *. *Лесно се забравя!*
```
int *iPtr6, iPtr7; // iPtr6 е указател от тип int, но iPtr7 е обикновен int!
```

#### Инициализация
**Синтаксис и семантика**
```
<type> *<name> = &<transmitter>;
```
Пример:
```
int a = 50;
int *ptr = &a;
```

По този начин правим следното: създали сме променлива от тип int и сме я инициализирали със стойност 50, след това създаваме променлива от тип указател към int на когото присвояваме адреса на а. Вземането на адрес на дадена променлива се прави чрез &(както казахме по-горе). Най - важното е да се разбере, че **указателите пазят адреса към паметта на това, с което искаме да оперираме**.
Пример:
```
int a = 50;
int *ptr = &a;

std::cout << *ptr << std::endl; // 50
std::cout << ++*ptr << std::endl; // 51
std::cout << a << std::endl; // 51
```

#### Нулеви стойности и нулеви указатели
Както всички променливи, указателите **могат да не се инициализират в началото**. Ако не е присвоена стойност на указателя, то той ще сочи някой **адрес по подразбиране**. Освен адрес към паметта, указателят може да съдържа и нулева стойност (null value). Нулевата стойност е специална стойност, която означава, че **указателят не сочи нищо/никъде (*или указателят сочи нищо*)**. Ако стойността на указателя е нулева, то той се нарича **null pointer (nullptr)**.

```
int *ptr(0); // ptr e nullptr
int * ptr2; // ptr не е инициализиран
ptr2 = 0; // prt e nullptr 
```

Тъй като нулев указател се оценява с 0, то той може да се използва в условни изрази и конснтрукции, за да се провери дали указателят е нулев указател или не.


