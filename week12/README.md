## Рекурсия (Recursion)

### Рекурсия в математиката
**Какво е рекурсивна функция?**
Ако в дефиницията на някаква функция се използва **самата функция**, дефиницията на функцията се нарича рекурсивна.
Пример: Ако n е произволно естествено число, следната дефиниция на функцията факториел е рекурсивна.
```
n! = 1, при n = 0
n! = n(n-1)!, при n > 0
```
Условието при n = 0 не съдържа обръщение към функцията факториел и нарича гранично условие (граничен/основен/базов случай или дъно).

### Случаи в рекурсията
**основен случай (base case)** - случаят, за който резултатът се получава директно
**общ случай (general case)** - случаят, при който резултатът се получава рекурсивно чрез опростяване при всяко повикване

**Правила за рекурсивни случаи:**
- Всяка рекурсивна дефиниция ***трябва*** да има поне един **основен случай**
- **Общият случай** трябва да следе до основен случай
- **Основният случай** спира рекурсия

Нека разгледаме изпълнението на функция факториел с естественото число 4:
```
4! = 4.3!                   //4 > 0 => 4! = 4.3!
4.3! = 4.3.2!               //3 > 0 => 3! = 3.2!
4.3.2! = 4.3.2.1!           //2 > 0 => 2! = 2.1!
4.3.2.1! = 4.3.2.1.0!       //1 > 0 => 1! = 1.0!
4.3.2.1.0! = 4.3.2.1.1      //0 = 0 => 0! = 1 (граничен случай)
4.3.2.1.1 = 4.3.2.1
4.3.2.1 = 4.3.2
4.3.2 = 4.6
4.6 = 24
```

### Рекурсия в C++
Знаем, че можем в една функция да извикаме всяка друга функция, която е дефинирана или декларирана до момента на извикването й. Освен това в С++ е разрешено функция да извиква сама себе си. **Функция , която се обръща пряко или косвено към себе си, се нарича рекурсивна.** Програма, която съдържа рекурсивна функция, е рекурсивна. Ще демонстрираме това чрез примера с факториел:
```
#include <iostream>

int fact (int n) {
    if (n == 0) {
        return 1;
    }

    return n * fact (n - 1);
}

int main() {
    cout << "x= ";  
	int x;  
	cin >> x;  
	
	cout << x << "! = " << fact(x) << '\n';  
	return 0; 
}
```

**Изпълнение на програмата**
Изпълнението на програмата започва с main функцията - въвеждаме стойността на х. Нека сме въвели 4. След това се изпълнява операторът
```
cout << x << "! = " << fact(x) << '\n';  
```

За целта трябва да се пресметне стойността на fact(x) за х = 4, след което да се изведе получената стойност.

Генерира се стекова рамка за това обръщение към функцията fact(4). В нея запозва изпълнението на тялото на функцията за параметър 4.
Тъй като n е различно от 0, се изпълнява операторът
```
return n * fact(n - 1);
```

По този начин преди завършването на първото обръщание към fact се прави второ обръщение към тази функция. За целта се генерира нова стекова рамка на функцията **fact(3), в която n = 3**. Тялото на функцията fact започва да се изпълнява за втори път. По аналогичен начин възникват още обръщения към функцията fact. **При последното от тях**, стойността на **n е равна на 0**.
При петото обръщение към fact стойността на **n е равна на 0**. В резултат, изпълнението на това обръщение завършва и за стойност на **fact се получава 1**.
След това последователно завършват изпълненията на останалите обръщения към тялото на функцията. При всяко изпълнение на тялото на функцията се определя съответната стойност на функцията fact. След завършването на всяко изпълнение на функцията fact, отделената за fact стекова рамка се освобождава. В крайна сметка в главната програма се връща 24 - стойността на 4!, която се извежда върху екрана.

***Забележка:***
В този случай, рекурсивното дефиниране на функцията факториел не е подходящо, тъй като съществува лесно итеративно решение.(Кажете го! :) )

**Препоръка: Ако за решаването на някаква задача може да се използва итеративен алгоритъм(цикъл), реализирайте го. Не се препоръчва винаги използването на рекурсия, тъй като това води до загуба на памет и време.**

### Рекурсивен срещу итеративен подход
Един от често задаваните въпроси за рекурсивни функции, е "Защо да използваме рекурсивна функция, ако можеш да вършиш много от същите задачи итеративно(използвайки цикъл или цикличен алгоритъм)?". Оказва се, че винаги можете да решите проблема, както рекурсивно, така и итеративно, за нетривиални проблеми, рекурсивната версия често е много по-лесна за писане (и четене). Например, за да напишем функцията Fibonacci итеративно, ще се мъчим доста, докато рекурсивното й решение е много интуитивно. Итерационните функции (тези, които използват цикъл) са почти винаги по-ефективни от рекурсивните им версии. Това е така, заради стековите рамки. Итерационните функции избягват тази разходи на памет. Това не означава, че итеративните функции винаги са по-добрия избор. Понякога рекурсивната версия на функция е по-чиста и по-лесна. Като цяло, рекурсията е добър избор, когато повечето от следните неща са верни:
- Рекурсивният код е много по-лесен за изпълнение.
- Дълбочината на рекурсията може да бъде ораничена(например няма начин да се осигури вход, който да доведе до самоизвикване на 100 000 нива).
- Итеративната версия на алгоритъма изисква управление на стек от данни.
- Не е критична за ефективността на кода.

Въпреки това, ако рекурсивният алгоритъм е по-прост за изпънение, може да има смисъл да започнете рекурсивно и след това да се оптимизира до итеративен алгоритъм.

### Видове рекурсия
https://www.geeksforgeeks.org/types-of-recursions/
1. Пряка рекурсия
    - линейна рекурсия
    - опашкова рекурсия
    - дървовидна рекурсия (разклонена)
    - вложена рекурсия
2. Косвена рекурсия

#### Пряка рекурсия
**Линейна рекурсия**
```
void func(int n) {
    if (n <= 0) {
        return;
    }

    func(n - 1);
    std::cout << n << " ";
}
```

**Опашкова рекурсия**
```
void func(int n) {
    if (n <= 0) {
        return;
    }

    std::cout << n << " ";
    func(n - 1);
}
```

**Дървовидна рекурсия(разклонена)**
```
int fibonacci(int n) {
    if (n < 2) {
        return n;
    }

    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

**Вложена рекурсия**
Ackermann function:

A(0, n)         = n + 1
A(m + 1, 0)     = A(m, 1)
A(m + 1, n + 1) = A(m, A(m + 1, n))

```
int ackermannFunction(int m, int n) {
    if (m == 0) {
        return n + 1;
    }

    if (m > 0 && n == 0) {
        return ackermannFunction(m - 1, 1);
    }

    if (m > 0 && n > 0) {
        return ackermannFunction(m - 1, ackermannFunction(m, n - 1));
    }
}
```

#### Косвена рекурсия
```
bool IsOddNumber(int n)
{
	if (0 == n) {
        return 0;
    }
	
	return IsEvenNumber(n - 1);
}

bool IsEvenNumber(int n)
{
	if (0 == n) {
        return 1;
    }
	
	return IsOddNumber(n - 1);
}
```




